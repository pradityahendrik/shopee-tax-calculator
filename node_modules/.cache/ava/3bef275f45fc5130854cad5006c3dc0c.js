'use strict';

const Promise = require('bluebird');

const test = require('ava');

const sinon = require('sinon');

const method = require('../../methods/bill');

const repository = require('../../repositories/bill');

sinon.createSandbox().usingPromise(Promise.Promise);
test.serial('[SUCCESS] Find All Data', async t => {
  t.context.sandbox.stub(repository, 'getBill').resolves([{
    "id": 1,
    "name": "Pizza",
    "tax_code": "1",
    "price": 12000,
    "code": 1,
    "type": "Food & Beverage",
    "refundable": "1"
  }, {
    "id": 2,
    "name": "Burger",
    "tax_code": "2",
    "price": 10000,
    "code": 2,
    "type": "Tobacco",
    "refundable": "0"
  }, {
    "id": 3,
    "name": "Cola",
    "tax_code": "3",
    "price": 8000,
    "code": 3,
    "type": "Entertainment",
    "refundable": "0"
  }, {
    "id": 4,
    "name": "Coke",
    "tax_code": "3",
    "price": 80,
    "code": 3,
    "type": "Entertainment",
    "refundable": "0"
  }]);

  try {
    const response = await method.getBill();
    t.deepEqual(response, [{
      "id": 1,
      "name": "Pizza",
      "tax_code": "1",
      "price": 12000,
      "code": 1,
      "type": "Food & Beverage",
      "refundable": "1"
    }, {
      "id": 2,
      "name": "Burger",
      "tax_code": "2",
      "price": 10000,
      "code": 2,
      "type": "Tobacco",
      "refundable": "0"
    }, {
      "id": 3,
      "name": "Cola",
      "tax_code": "3",
      "price": 8000,
      "code": 3,
      "type": "Entertainment",
      "refundable": "0"
    }, {
      "id": 4,
      "name": "Coke",
      "tax_code": "3",
      "price": 80,
      "code": 3,
      "type": "Entertainment",
      "refundable": "0"
    }]);
  } catch (err) {
    t.fail(err.message);
  }
});
test.serial('[SUCCESS] Return empty data', async t => {
  t.context.sandbox.stub(repository, 'getBill').resolves([]);

  try {
    const response = await method.getBill();
    t.deepEqual(response, []);
  } catch (err) {
    t.fail(err.message);
  }
});
test.serial('[FAILED] Error', async t => {
  t.context.sandbox.stub(repository, 'getBill').rejects();

  try {
    await method.getBill();
  } catch (err) {
    console.log(err);
    t.deepEqual(err.message, {
      message: 'Error'
    });
  }
});
test.beforeEach('Initialize New Sandbox Before Each Test', async t => {
  t.context.sandbox = sinon.createSandbox().usingPromise(Promise.Promise);
});
test.afterEach.always('Restore Sandbox and Configuration After Each Test', async t => {
  t.context.sandbox.restore();
});
//# sourceMappingURL=/Users/pradityahendrik/shopee/node_modules/.cache/ava/3bef275f45fc5130854cad5006c3dc0c.js.map