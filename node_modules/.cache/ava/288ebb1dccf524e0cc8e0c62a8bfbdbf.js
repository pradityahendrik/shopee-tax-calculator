'use strict';

const Promise = require('bluebird');

const test = require('ava');

const sinon = require('sinon');

const method = require('../../methods/users');

const repository = require('../../repositories/users');

sinon.createSandbox().usingPromise(Promise.Promise);
test.serial('[SUCCESS] Find All Data', async t => {
  t.context.sandbox.stub(repository, 'findAll').resolves([{
    "id": 1,
    "name": "a",
    "address": "a"
  }, {
    "id": 2,
    "name": "b",
    "address": "b"
  }]);

  try {
    const response = await method.findAllUser();
    t.deepEqual(response.response.data, [{
      "id": 1,
      "name": "a",
      "address": "a"
    }, {
      "id": 2,
      "name": "b",
      "address": "b"
    }]);
  } catch (err) {
    t.fail(err.message);
  }
});
test.serial('[SUCCESS] Return empty data', async t => {
  t.context.sandbox.stub(repository, 'findAll').resolves([]);

  try {
    const response = await method.findAllUser();
    t.deepEqual(response.response.data, []);
  } catch (err) {
    t.fail(err.message);
  }
});
test.serial('[FAILED] Error', async t => {
  t.context.sandbox.stub(repository, 'findAll').rejects();

  try {
    const response = await method.findAllUser();
    t.deepEqual(response.response.data, null);
  } catch (err) {
    t.fail(err.message);
  }
});
test.beforeEach('Initialize New Sandbox Before Each Test', async t => {
  t.context.sandbox = sinon.createSandbox().usingPromise(Promise.Promise);
});
test.afterEach.always('Restore Sandbox and Configuration After Each Test', async t => {
  t.context.sandbox.restore();
});
//# sourceMappingURL=/Users/pradityahendrik/shopee/node_modules/.cache/ava/288ebb1dccf524e0cc8e0c62a8bfbdbf.js.map